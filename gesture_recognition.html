<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Comm - Gesture Recognition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #000;
            color: white;
            height: 100vh;
            overflow: hidden;
        }

        .entry-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .entry-content {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 60px 40px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .entry-content h1 {
            font-size: 3rem;
            margin-bottom: 40px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .entry-button {
            font-size: 1.5rem;
            padding: 20px 40px;
            background: linear-gradient(45deg, #ff6b6b, #ffa500);
            border: none;
            border-radius: 50px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 20px rgba(255, 107, 107, 0.3);
        }

        .entry-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 30px rgba(255, 107, 107, 0.4);
        }

        .main-interface {
            position: relative;
            width: 100%;
            height: 100vh;
            display: none;
        }

        .video-container {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
        }

        #mainVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
        }

        .transition-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(240,240,240,0.7) 50%, rgba(255,255,255,0.9) 100%);
            opacity: 0;
            pointer-events: none;
            z-index: 10;
            transition: opacity 0.3s ease;
        }

        .transition-overlay.flash {
            opacity: 1;
        }

        .status-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 20;
            font-weight: bold;
        }

        .status-indicator.person-detected {
            background: rgba(0, 255, 0, 0.3);
            border-color: rgba(0, 255, 0, 0.5);
        }

        .status-indicator.gesture-detected {
            background: rgba(255, 165, 0, 0.3);
            border-color: rgba(255, 165, 0, 0.5);
        }

        .debug-info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            font-size: 14px;
            z-index: 20;
        }

        @media (max-width: 768px) {
            .entry-content {
                padding: 40px 30px;
            }
            
            .entry-content h1 {
                font-size: 2rem;
            }
            
            .entry-button {
                font-size: 1.2rem;
                padding: 15px 30px;
            }
            
            .status-indicator, .debug-info {
                font-size: 12px;
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="entry-popup" id="entryPopup">
        <div class="entry-content">
            <h1>Digital Communication Interface</h1>
            <button class="entry-button" onclick="startApp()">Start Experience</button>
        </div>
    </div>

    <div class="main-interface" id="mainInterface">
        <div class="video-container">
            <video id="mainVideo" autoplay muted loop>
                <source src="/videos/interactive_dalia_STANDBY.mp4" type="video/mp4">
                Your browser does not support the video tag.
            </video>
            <div class="transition-overlay" id="transitionOverlay"></div>
        </div>
        
        <div class="status-indicator" id="statusIndicator">
            Waiting for detection...
        </div>
        
        <div class="debug-info" id="debugInfo">
            Status: Standby<br>
            Video: Standby Loop<br>
            Connection: Disconnected
        </div>
    </div>

    <script>
        class GestureVideoPlayer {
            constructor() {
                this.video = document.getElementById('mainVideo');
                this.overlay = document.getElementById('transitionOverlay');
                this.statusIndicator = document.getElementById('statusIndicator');
                this.debugInfo = document.getElementById('debugInfo');
                this.socket = null;
                this.currentState = 'standby';
                this.isTransitioning = false;
                this.videoQueue = [];
                this.gestureVideos = {
                    'thumbs_up': '/videos/interactive_dalia_THUMBSUP_finale.mp4',
                    'peace_sign': '/videos/interactive_dalia_PEACESIGN.mp4',
                    'middle_finger': '/videos/interactive_dalia_MIDDLEFINGER.mp4'
                };
                this.lastGestureTime = 0;
                this.gestureTimeout = 3000;
                this.connectionRetries = 0;
                this.isConnected = false;
                this.pingInterval = null;
                this.reconnectTimeout = null;
                
                this.init();
            }
            
            init() {
                this.setupVideoEvents();
                this.setupAudioUnmute();
                this.updateDebugInfo('Initialized', 'Standby Loop', 'Waiting...');
                
                setTimeout(() => {
                    this.connectWebSocket();
                }, 3000);
            }
            
            setupVideoEvents() {
                this.video.addEventListener('ended', () => this.onVideoEnded());
                this.video.addEventListener('loadstart', () => this.onVideoLoadStart());
                this.video.addEventListener('canplay', () => this.onVideoCanPlay());
                this.video.addEventListener('error', (e) => this.onVideoError(e));
            }
            
            setupAudioUnmute() {
                const unmuteVideo = () => {
                    if (this.currentState !== 'standby') {
                        this.video.muted = false;
                        this.video.volume = 1.0;
                    }
                    document.removeEventListener('click', unmuteVideo);
                    document.removeEventListener('touchstart', unmuteVideo);
                };
                
                document.addEventListener('click', unmuteVideo);
                document.addEventListener('touchstart', unmuteVideo);
            }
            
            connectWebSocket() {
                if (this.socket && (this.socket.readyState === WebSocket.CONNECTING || this.socket.readyState === WebSocket.OPEN)) {
                    return;
                }
                
                this.updateDebugInfo(this.currentState, this.getCurrentVideoName(), 'Connecting...');
                
                try {
                    this.socket = new WebSocket('ws://localhost:8765');
                    
                    this.socket.onopen = () => {
                        console.log('WebSocket connected successfully');
                        this.updateDebugInfo(this.currentState, this.getCurrentVideoName(), 'Connected');
                        this.connectionRetries = 0;
                        this.isConnected = true;
                        
                        this.sendPing();
                        this.pingInterval = setInterval(() => {
                            this.sendPing();
                        }, 30000);
                    };
                    
                    this.socket.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            if (data.type === 'connection') {
                                console.log('Received welcome message:', data.message);
                            } else if (data.type === 'pong') {
                                console.log('Received pong');
                            } else {
                                this.handleDetectionData(data);
                            }
                        } catch (error) {
                            console.error('Error parsing WebSocket data:', error);
                        }
                    };
                    
                    this.socket.onclose = (event) => {
                        this.isConnected = false;
                        if (this.pingInterval) {
                            clearInterval(this.pingInterval);
                            this.pingInterval = null;
                        }
                        
                        if (event.code === 1000) {
                            console.log('WebSocket closed normally');
                        } else {
                            console.log('WebSocket disconnected:', event.code, event.reason);
                            this.scheduleReconnect();
                        }
                        this.updateDebugInfo(this.currentState, this.getCurrentVideoName(), 'Disconnected');
                    };
                    
                    this.socket.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.updateDebugInfo(this.currentState, this.getCurrentVideoName(), 'Error');
                        this.isConnected = false;
                    };
                    
                    setTimeout(() => {
                        if (this.socket && this.socket.readyState === WebSocket.CONNECTING) {
                            console.log('Connection timeout, closing socket');
                            this.socket.close();
                            this.scheduleReconnect();
                        }
                    }, 10000);
                    
                } catch (error) {
                    console.error('Failed to create WebSocket:', error);
                    this.updateDebugInfo(this.currentState, this.getCurrentVideoName(), 'Failed');
                    this.scheduleReconnect();
                }
            }
            
            sendPing() {
                if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                    try {
                        this.socket.send(JSON.stringify({
                            type: 'ping',
                            timestamp: Date.now()
                        }));
                    } catch (error) {
                        console.error('Error sending ping:', error);
                    }
                }
            }
            
            scheduleReconnect() {
                if (!this.connectionRetries) this.connectionRetries = 0;
                this.connectionRetries++;
                
                const delay = Math.min(3000 + (this.connectionRetries * 2000), 15000);
                console.log(`Reconnecting in ${delay}ms (attempt ${this.connectionRetries})`);
                
                this.reconnectTimeout = setTimeout(() => {
                    if (!this.socket || this.socket.readyState === WebSocket.CLOSED) {
                        this.connectWebSocket();
                    }
                }, delay);
            }
            
            handleDetectionData(data) {
                if (!data) return;
                
                const now = Date.now();
                
                if (data.person_count > 0 && this.currentState === 'standby') {
                    this.playIntroVideo();
                    this.statusIndicator.textContent = 'Person detected!';
                    this.statusIndicator.className = 'status-indicator person-detected';
                } else if (data.gesture && data.gesture !== 'unknown' && data.gesture !== '') {
                    if (now - this.lastGestureTime > this.gestureTimeout) {
                        this.handleGesture(data.gesture);
                        this.lastGestureTime = now;
                        this.statusIndicator.textContent = `Gesture: ${data.gesture}`;
                        this.statusIndicator.className = 'status-indicator gesture-detected';
                    }
                } else if (data.person_count === 0 && this.currentState !== 'standby' && !this.isTransitioning) {
                    setTimeout(() => {
                        if (this.currentState !== 'standby') {
                            this.returnToStandby();
                        }
                    }, 2000);
                }
                
                this.updateDebugInfo(
                    this.currentState,
                    this.getCurrentVideoName(),
                    this.socket && this.socket.readyState === WebSocket.OPEN ? 'Connected' : 'Reconnecting'
                );
            }
            
            async playIntroVideo() {
                if (this.isTransitioning) return;
                
                this.currentState = 'intro';
                await this.transitionToVideo('/videos/interactive_dalia_INTRO_2.mp4', false, true);
            }
            
            async handleGesture(gesture) {
                if (this.isTransitioning) return;
                
                const gestureKey = gesture.toLowerCase().replace(' ', '_');
                const videoPath = this.gestureVideos[gestureKey];
                
                if (videoPath) {
                    this.currentState = 'gesture';
                    await this.transitionToVideo(videoPath, false, true);
                }
            }
            
            async returnToStandby() {
                if (this.isTransitioning || this.currentState === 'standby') return;
                
                this.currentState = 'standby';
                this.statusIndicator.textContent = 'Waiting for detection...';
                this.statusIndicator.className = 'status-indicator';
                await this.transitionToVideo('/videos/interactive_dalia_STANDBY.mp4', true, false);
            }
            
            async transitionToVideo(videoSrc, shouldLoop, withSound) {
                if (this.isTransitioning) return;
                
                this.isTransitioning = true;
                
                return new Promise((resolve, reject) => {
                    this.showTransition();
                    
                    const newVideo = document.createElement('video');
                    newVideo.src = videoSrc;
                    newVideo.autoplay = true;
                    newVideo.loop = shouldLoop;
                    newVideo.muted = !withSound;
                    newVideo.volume = withSound ? 1.0 : 0;
                    newVideo.style.width = '100%';
                    newVideo.style.height = '100%';
                    newVideo.style.objectFit = 'cover';
                    newVideo.style.position = 'absolute';
                    newVideo.style.top = '0';
                    newVideo.style.left = '0';
                    
                    const onCanPlay = () => {
                        const container = this.video.parentNode;
                        const oldVideo = this.video;
                        
                        container.insertBefore(newVideo, oldVideo);
                        
                        setTimeout(() => {
                            if (oldVideo.parentNode) {
                                oldVideo.parentNode.removeChild(oldVideo);
                            }
                        }, 100);
                        
                        this.video = newVideo;
                        this.setupVideoEvents();
                        
                        setTimeout(() => {
                            this.hideTransition();
                            this.isTransitioning = false;
                            resolve();
                        }, 150);
                        
                        newVideo.removeEventListener('canplay', onCanPlay);
                        newVideo.removeEventListener('error', onError);
                    };
                    
                    const onError = (error) => {
                        newVideo.removeEventListener('canplay', onCanPlay);
                        newVideo.removeEventListener('error', onError);
                        this.hideTransition();
                        this.isTransitioning = false;
                        reject(error);
                    };
                    
                    newVideo.addEventListener('canplay', onCanPlay);
                    newVideo.addEventListener('error', onError);
                    newVideo.load();
                });
            }
            
            onVideoEnded() {
                if (this.currentState === 'intro' || this.currentState === 'gesture') {
                    setTimeout(() => {
                        this.returnToStandby();
                    }, 500);
                }
            }
            
            showTransition() {
                this.overlay.classList.add('flash');
            }
            
            hideTransition() {
                this.overlay.classList.remove('flash');
            }
            
            getCurrentVideoName() {
                if (this.currentState === 'standby') return 'Standby Loop';
                if (this.currentState === 'intro') return 'Intro';
                if (this.currentState === 'gesture') return 'Gesture Response';
                return 'Unknown';
            }
            
            updateDebugInfo(state, video, connection) {
                this.debugInfo.innerHTML = `
                    Status: ${state}<br>
                    Video: ${video}<br>
                    Connection: ${connection}
                `;
            }
            
            onVideoLoadStart() {
                console.log('Video loading started');
            }
            
            onVideoCanPlay() {
                console.log('Video can play');
            }
            
            onVideoError(error) {
                console.error('Video error:', error);
                this.showError('Video playback error');
            }
            
            showError(message) {
                const errorDiv = document.createElement('div');
                errorDiv.textContent = message;
                errorDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(255, 0, 0, 0.8);
                    color: white;
                    padding: 20px;
                    border-radius: 10px;
                    z-index: 1000;
                    font-size: 16px;
                    font-weight: bold;
                `;
                
                document.body.appendChild(errorDiv);
                
                setTimeout(() => {
                    if (errorDiv.parentNode) {
                        errorDiv.parentNode.removeChild(errorDiv);
                    }
                }, 3000);
            }
            
            cleanup() {
                if (this.pingInterval) {
                    clearInterval(this.pingInterval);
                    this.pingInterval = null;
                }
                
                if (this.reconnectTimeout) {
                    clearTimeout(this.reconnectTimeout);
                    this.reconnectTimeout = null;
                }
                
                if (this.socket) {
                    this.socket.close(1000, 'Page unloading');
                    this.socket = null;
                }
                
                this.isConnected = false;
            }
        }

        let player;

        function startApp() {
            document.getElementById('entryPopup').style.display = 'none';
            document.getElementById('mainInterface').style.display = 'block';
            
            setTimeout(() => {
                player = new GestureVideoPlayer();
                
                window.addEventListener('beforeunload', () => {
                    if (player) {
                        player.cleanup();
                    }
                });
                
                window.addEventListener('unload', () => {
                    if (player) {
                        player.cleanup();
                    }
                });
            }, 2000);
        }
    </script>
</body>
</html>